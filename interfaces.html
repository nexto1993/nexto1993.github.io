<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaces - C# OOP</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
        }
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        .code-block {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            border: 1px solid #3c3c3c;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .code-block::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(90deg, #ff5f56, #ffbd2e, #27ca3f);
            border-radius: 8px 8px 0 0;
        }
        .code-block::after {
            content: "‚óè‚óè‚óè";
            position: absolute;
            top: 8px;
            left: 12px;
            color: #1e1e1e;
            font-size: 8px;
            letter-spacing: 2px;
        }
        .code-content {
            margin-top: 30px;
            white-space: pre-wrap;
        }
        .keyword {
            color: #569cd6;
            font-weight: 500;
        }
        .string {
            color: #ce9178;
        }
        .comment {
            color: #6a9955;
            font-style: italic;
        }
        .type {
            color: #4ec9b0;
        }
        .concept-box {
            background-color: #e8f4fd;
            border: 1px solid #bee3f8;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .concept-title {
            color: #2b6cb0;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
            border-radius: 4px;
        }
        .navigation {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
        }
        .nav-link {
            color: #3498db;
            text-decoration: none;
            font-weight: bold;
            padding: 10px 20px;
            border: 2px solid #3498db;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .nav-link:hover {
            background-color: #3498db;
            color: white;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f8f9fa;
            font-weight: bold;
            color: #2c3e50;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .syntax-box {
            background-color: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .syntax-title {
            color: #2e7d32;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .interface-type {
            background-color: #f1f3f4;
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid #9c27b0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            margin: 10px 0;
        }
        .error-box {
            background-color: #ffeaea;
            border: 1px solid #ffcdd2;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #c62828;
        }
        .success-box {
            background-color: #e8f5e8;
            border: 1px solid #c8e6c9;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #2e7d32;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interfaces in C#</h1>
        <p style="text-align: center; color: #7f8c8d; margin-bottom: 30px;">
            Understanding interfaces, contracts, and multiple implementation in C#
        </p>

        <h2>üìã Code Analysis</h2>

        <h3>ILoader Interface (ILoader.cs)</h3>
        <div class="code-block">
            <div class="code-content"><span class="keyword">namespace</span> <span class="type">Interfaces</span>
{
    <span class="keyword">public interface</span> <span class="type">ILoader</span>
    {
        <span class="comment">// Default implementation (C# 8.0+)</span>
        <span class="keyword">void</span> Load()
        {
            <span class="type">Console</span>.WriteLine(<span class="string">"Default"</span>);
        }
        
        <span class="comment">// Abstract method - must be implemented</span>
        <span class="keyword">void</span> Unload();
    }
}</div>
        </div>

        <h3>Vehicle Classes (Vehicle.cs)</h3>
        <div class="code-block">
            <div class="code-content"><span class="keyword">namespace</span> <span class="type">Interfaces</span>
{
    <span class="comment">// Abstract base class</span>
    <span class="keyword">public abstract class</span> <span class="type">Vehicle</span>
    {
        <span class="keyword">protected</span> <span class="type">string</span> Brand;
        <span class="keyword">protected</span> <span class="type">string</span> Year;
        <span class="keyword">protected</span> <span class="type">string</span> Model;

        <span class="keyword">public</span> Vehicle(<span class="type">string</span> brand, <span class="type">string</span> year, <span class="type">string</span> model)
        {
            Brand = brand;
            Year = year;
            Model = model;
        }
    }

    <span class="comment">// Simple inheritance - no interface</span>
    <span class="keyword">public class</span> <span class="type">Honda</span> : <span class="type">Vehicle</span> 
    {
        <span class="keyword">public</span> Honda(<span class="type">string</span> brand, <span class="type">string</span> year, <span class="type">string</span> model) : <span class="keyword">base</span>(brand, year, model) 
        {
            
        }
    }

    <span class="comment">// Multiple inheritance: class + interface</span>
    <span class="keyword">public class</span> <span class="type">Caterpiller</span>: <span class="type">Vehicle</span>, <span class="type">ILoader</span>
    {
        <span class="keyword">public</span> Caterpiller(<span class="type">string</span> brand, <span class="type">string</span> year, <span class="type">string</span> model) : <span class="keyword">base</span>(brand, year, model)
        {

        }

        <span class="comment">// Override default interface implementation</span>
        <span class="keyword">public void</span> Load()
        {
            <span class="keyword">throw new</span> <span class="type">NotImplementedException</span>();
        }

        <span class="comment">// Implement required interface method</span>
        <span class="keyword">public void</span> Unload()
        {
            <span class="keyword">throw new</span> <span class="type">NotImplementedException</span>();
        }
    }
}</div>
        </div>

        <h3>Program Class (Program.cs)</h3>
        <div class="code-block">
            <div class="code-content"><span class="keyword">namespace</span> <span class="type">Interfaces</span>
{
    <span class="keyword">internal class</span> <span class="type">Program</span>
    {
        <span class="keyword">static void</span> Main(<span class="type">string</span>[] args)
        {
            <span class="type">Console</span>.WriteLine(<span class="string">"Hello, World!"</span>);
        }
    }
}</div>
        </div>

        <h2>üîë Key Concepts Explained</h2>

        <div class="concept-box">
            <div class="concept-title">1. What are Interfaces?</div>
            <p><strong>Definition:</strong> Interfaces define contracts that implementing classes must follow.</p>
            <div class="interface-type">public interface IExample { void Method(); }</div>
            <ul>
                <li>Define method signatures without implementation (traditionally)</li>
                <li>Support default implementations (C# 8.0+)</li>
                <li>Enable multiple inheritance in C#</li>
                <li>Provide abstraction and loose coupling</li>
                <li>All members are public by default</li>
                <li>Cannot contain fields, only properties, methods, events</li>
            </ul>
        </div>

        <div class="concept-box">
            <div class="concept-title">2. Interface Implementation Rules</div>
            <div class="syntax-box">
                <div class="syntax-title">Implementation Requirements:</div>
                <ul>
                    <li><strong>Must implement:</strong> All abstract methods (no default implementation)</li>
                    <li><strong>Can override:</strong> Methods with default implementations</li>
                    <li><strong>Access modifier:</strong> Implementation must be public</li>
                    <li><strong>Multiple interfaces:</strong> Class can implement multiple interfaces</li>
                </ul>
            </div>
        </div>

        <div class="concept-box">
            <div class="concept-title">3. Default Interface Methods (C# 8.0+)</div>
            <p><strong>New Feature:</strong> Interfaces can now provide default implementations.</p>
            <div class="success-box">
                <strong>Benefits:</strong>
                <ul>
                    <li>Interface evolution without breaking existing implementations</li>
                    <li>Reduce code duplication across implementations</li>
                    <li>Provide common behavior while allowing customization</li>
                </ul>
            </div>
            <div class="error-box">
                <strong>Limitations:</strong>
                <ul>
                    <li>Cannot access instance fields of implementing class</li>
                    <li>Must be called through interface reference</li>
                    <li>Static members only accessible through interface name</li>
                </ul>
            </div>
        </div>

        <div class="concept-box">
            <div class="concept-title">4. Multiple Inheritance with Interfaces</div>
            <p><strong>C# Limitation:</strong> Single class inheritance, but multiple interface implementation.</p>
            <div class="interface-type">
                public class Caterpiller : Vehicle, ILoader, IAnotherInterface
            </div>
            <ul>
                <li><strong>One base class:</strong> Can inherit from only one class</li>
                <li><strong>Multiple interfaces:</strong> Can implement multiple interfaces</li>
                <li><strong>Order matters:</strong> Base class first, then interfaces</li>
                <li><strong>Name conflicts:</strong> Explicit interface implementation resolves conflicts</li>
            </ul>
        </div>

        <h2>üìä Interfaces vs Abstract Classes</h2>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Interface</th>
                    <th>Abstract Class</th>
                    <th>When to Use</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Instantiation</strong></td>
                    <td>Cannot instantiate</td>
                    <td>Cannot instantiate</td>
                    <td>Both for abstraction</td>
                </tr>
                <tr>
                    <td><strong>Multiple Inheritance</strong></td>
                    <td>Yes (multiple interfaces)</td>
                    <td>No (single inheritance)</td>
                    <td>Interface for multiple contracts</td>
                </tr>
                <tr>
                    <td><strong>Implementation</strong></td>
                    <td>Default methods (C# 8.0+)</td>
                    <td>Abstract and concrete methods</td>
                    <td>Abstract class for shared code</td>
                </tr>
                <tr>
                    <td><strong>Fields</strong></td>
                    <td>No instance fields</td>
                    <td>All field types allowed</td>
                    <td>Abstract class for state</td>
                </tr>
                <tr>
                    <td><strong>Access Modifiers</strong></td>
                    <td>Public by default</td>
                    <td>All access levels</td>
                    <td>Abstract class for encapsulation</td>
                </tr>
                <tr>
                    <td><strong>Constructor</strong></td>
                    <td>No constructors</td>
                    <td>Can have constructors</td>
                    <td>Abstract class for initialization</td>
                </tr>
            </tbody>
        </table>

        <h2>üîÑ Enhanced Implementation Example</h2>
        <div class="code-block">
            <div class="code-content"><span class="comment">// Enhanced interface with properties and events</span>
<span class="keyword">public interface</span> <span class="type">IAdvancedLoader</span>
{
    <span class="comment">// Properties</span>
    <span class="type">string</span> LoaderName { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="type">bool</span> IsLoaded { <span class="keyword">get</span>; }
    
    <span class="comment">// Event</span>
    <span class="keyword">event</span> <span class="type">EventHandler</span>&lt;<span class="type">string</span>&gt; LoadCompleted;
    
    <span class="comment">// Methods</span>
    <span class="keyword">void</span> Load();
    <span class="keyword">void</span> Unload();
    
    <span class="comment">// Default implementation</span>
    <span class="keyword">void</span> Reset()
    {
        <span class="type">Console</span>.WriteLine($<span class="string">"Resetting {LoaderName}..."</span>);
        <span class="keyword">if</span> (IsLoaded)
        {
            Unload();
        }
    }
}

<span class="comment">// Practical implementation</span>
<span class="keyword">public class</span> <span class="type">FileLoader</span> : <span class="type">IAdvancedLoader</span>
{
    <span class="keyword">public</span> <span class="type">string</span> LoaderName { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="keyword">public</span> <span class="type">bool</span> IsLoaded { <span class="keyword">private set</span>; <span class="keyword">get</span>; }
    
    <span class="keyword">public event</span> <span class="type">EventHandler</span>&lt;<span class="type">string</span>&gt; LoadCompleted;
    
    <span class="keyword">public</span> FileLoader(<span class="type">string</span> name)
    {
        LoaderName = name;
    }
    
    <span class="keyword">public void</span> Load()
    {
        <span class="type">Console</span>.WriteLine($<span class="string">"Loading {LoaderName}..."</span>);
        IsLoaded = <span class="keyword">true</span>;
        LoadCompleted?.Invoke(<span class="keyword">this</span>, $<span class="string">"{LoaderName} loaded successfully"</span>);
    }
    
    <span class="keyword">public void</span> Unload()
    {
        <span class="type">Console</span>.WriteLine($<span class="string">"Unloading {LoaderName}..."</span>);
        IsLoaded = <span class="keyword">false</span>;
    }
    
    <span class="comment">// Can use default Reset() method or override it</span>
}</div>
        </div>

        <h2>üí° Design Patterns with Interfaces</h2>
        <div class="concept-box">
            <div class="concept-title">Common Interface Patterns</div>
            <ul>
                <li><strong>Repository Pattern:</strong> IRepository&lt;T&gt; for data access abstraction</li>
                <li><strong>Strategy Pattern:</strong> IStrategy for interchangeable algorithms</li>
                <li><strong>Factory Pattern:</strong> IFactory&lt;T&gt; for object creation</li>
                <li><strong>Observer Pattern:</strong> IObserver&lt;T&gt; for event notifications</li>
                <li><strong>Command Pattern:</strong> ICommand for encapsulating requests</li>
                <li><strong>Adapter Pattern:</strong> Interface for incompatible class integration</li>
            </ul>
        </div>

        <h2>üîß Best Practices</h2>
        <div class="highlight">
            <h4>Interface Design Guidelines:</h4>
            <ul>
                <li><strong>Interface Segregation:</strong> Keep interfaces small and focused (ISP)</li>
                <li><strong>Naming Convention:</strong> Start interface names with 'I' (IDisposable, IComparable)</li>
                <li><strong>Cohesion:</strong> Group related methods in the same interface</li>
                <li><strong>Stability:</strong> Avoid frequent changes to public interfaces</li>
                <li><strong>Default Methods:</strong> Use sparingly, prefer composition over inheritance</li>
                <li><strong>Documentation:</strong> Clearly document expected behavior and contracts</li>
                <li><strong>Generic Interfaces:</strong> Use generics for type safety and reusability</li>
            </ul>
        </div>

        <h2>üöÄ Practical Applications</h2>
        <p>Interfaces are essential for:</p>
        <ul>
            <li><strong>Dependency Injection:</strong> Loose coupling between components</li>
            <li><strong>Unit Testing:</strong> Mock objects and test doubles</li>
            <li><strong>Plugin Architecture:</strong> Extensible applications</li>
            <li><strong>API Design:</strong> Consistent contracts across implementations</li>
            <li><strong>Framework Development:</strong> Extensible and maintainable frameworks</li>
            <li><strong>Microservices:</strong> Service contracts and communication protocols</li>
        </ul>

        <div class="navigation">
            <a href="index.html" class="nav-link">‚Üê Back to Index</a>
        </div>
    </div>
</body>
</html>
